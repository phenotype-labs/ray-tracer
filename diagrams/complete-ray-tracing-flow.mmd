%% Complete Ray Tracer Architecture - WebGPU Rust Implementation
%% All-in-one comprehensive flow diagram

graph TB
    Start["ğŸ¯ RAY TRACER PIPELINE START"] --> CPUPhase

    subgraph CPUPhase["â”â”â” CPU SIDE (Rust) â”â”â”"]
        Camera["ğŸ“· Camera (camera.rs)<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>â€¢ Position: Vec3<br/>â€¢ Yaw/Pitch angles<br/>â€¢ Calculate basis vectors:<br/>  - forward() from angles<br/>  - right() = forward Ã— Y_UP<br/>  - up() = fixed Y_UP"]

        GridBuilder["ğŸ”² Grid Builder (grid.rs)<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>â€¢ 4 hierarchical levels<br/>â€¢ Cell sizes: 128â†’64â†’32â†’16<br/>â€¢ Coarse: u8 counts (3 levels)<br/>â€¢ Fine: Vec&lt;Vec&lt;u32&gt;&gt; indices<br/>â€¢ MAX: 8192 objects/cell"]

        GLTFLoader["ğŸ“¦ glTF Loader<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>â€¢ Parse meshes/materials<br/>â€¢ Extract geometry (v0,v1,v2,UVs)<br/>â€¢ Load PBR textures<br/>â€¢ Build triangle buffer<br/>â€¢ Extract emissive materials"]

        Camera --> BufferPrep
        GridBuilder --> BufferPrep
        GLTFLoader --> BufferPrep
    end

    subgraph BufferPrep["â”â”â” GPU BUFFER PREPARATION â”â”â”"]
        PerFrame["â±ï¸ Per-Frame Uploads (96B)<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>CameraUniform:<br/>â€¢ position, forward, right, up<br/>â€¢ time (animation)<br/>â€¢ lod_factor = h/(2*tan(FOV/2))<br/>â€¢ min_pixel_size = 2.0"]

        StaticBuffers["ğŸ’¾ Static Buffers (Once)<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>â€¢ Grid Metadata (96B)<br/>â€¢ Coarse Grid (u8 array)<br/>â€¢ Fine Grid (32KB/cell âš ï¸)<br/>â€¢ Boxes (128B each)<br/>â€¢ Triangles (80B each)<br/>â€¢ Materials (64B each)<br/>â€¢ Texture Array (2D array)"]
    end

    BufferPrep --> GPUDispatch["ğŸš€ COMPUTE DISPATCH<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Workgroups: (width/8, height/8, 1)<br/>8Ã—8 threads per workgroup<br/>1 thread = 1 pixel"]

    GPUDispatch --> GPUPhase

    subgraph GPUPhase["â”â”â” GPU COMPUTE SHADER (WGSL) â”â”â”"]

        RayGen["Stage 1ï¸âƒ£: RAY GENERATION<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>pixel_xy â†’ UV [0,1] â†’ NDC [-1,1]<br/><br/>ray.direction = normalize(<br/>  camera.forward +<br/>  camera.right * ndc.x * aspect * fov +<br/>  camera.up * -ndc.y * fov<br/>)<br/>ray.origin = camera.position"]

        BounceLoop["ğŸ” BOUNCE LOOP (MAX 8)<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"]

        RayGen --> BounceLoop

        BounceLoop --> MovingBox["2A: Moving Box Pre-Pass<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>âš ï¸ BYPASSES GRID<br/>â€¢ Brute force: last 3 boxes<br/>â€¢ Interpolate position:<br/>  t = (sin(time*2)+1)*0.5<br/>  center = mix(c0, c1, t)"]

        MovingBox --> GridCheck["2B: Grid Bounds Check<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>IF ray.origin inside grid:<br/>  entry = ray.origin<br/>ELSE:<br/>  t = intersect_aabb(grid_bounds)<br/>  IF t < 0: return SKY â˜ï¸<br/>  entry = ray(t + 0.001)"]

        GridCheck --> DDASetup["2C: DDA SETUP<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>current_cell = world_to_grid(entry)<br/><br/>step = sign(ray.direction)<br/>  â†’  Â±1 per axis<br/><br/>t_delta = |cell_size / ray.dir|<br/>  â†’ CONSTANT (never changes)<br/><br/>t_max = (next_boundary - pos) / ray.dir<br/>  â†’ Updated each step"]

        DDASetup --> DDALoop["2D: DDA LOOP (i=0..200)<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"]

        DDALoop --> GetCell["ğŸ“ Get Fine Cell<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>idx = x + y*nx + z*nx*ny<br/>cell = fine_cells[idx]<br/>count = cell.count (â‰¤8192)"]

        GetCell --> TestCell["ğŸ” Test All Objects in Cell<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>FOR j = 0 to count:<br/>  obj_id = cell.indices[j]<br/><br/>  IF obj_id < num_boxes:<br/>    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br/>    â”‚ INTERSECT_BOX        â”‚<br/>    â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚<br/>    â”‚ â€¢ AABB slab method   â”‚<br/>    â”‚ â€¢ inv_dir = 1/ray.dirâ”‚<br/>    â”‚ â€¢ t_min/t_max test   â”‚<br/>    â”‚ â€¢ Calculate normal   â”‚<br/>    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜<br/>  ELSE:<br/>    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br/>    â”‚ INTERSECT_TRIANGLE   â”‚<br/>    â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚<br/>    â”‚ â€¢ MÃ¶ller-Trumbore    â”‚<br/>    â”‚ â€¢ Barycentric coords â”‚<br/>    â”‚ â€¢ Texture sampling   â”‚<br/>    â”‚ â€¢ Alpha masking      â”‚<br/>    â”‚ â€¢ Normal mapping     â”‚<br/>    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜<br/><br/>Keep closest hit"]

        TestCell --> EarlyExit{"âš¡ Early Exit?<br/>â”â”â”â”â”â”â”â”â”â”â”<br/>hit.distance <<br/>min(t_max)?"}

        EarlyExit -->|YES| Shading
        EarlyExit -->|NO| StepCell

        StepCell["â¡ï¸ Step to Next Cell<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Choose axis with smallest t_max:<br/><br/>IF t_max.x is smallest:<br/>  cell.x += step.x<br/>  t_max.x += t_delta.x<br/>ELSE IF t_max.y is smallest:<br/>  cell.y += step.y<br/>  t_max.y += t_delta.y<br/>ELSE:<br/>  cell.z += step.z<br/>  t_max.z += t_delta.z"]

        StepCell --> BoundsCheck{"Cell in<br/>bounds?"}

        BoundsCheck -->|YES| LoopCheck{"i < 200?"}
        BoundsCheck -->|NO| Shading

        LoopCheck -->|YES| DDALoop
        LoopCheck -->|NO| Shading

        Shading["2E: SHADING ğŸ¨<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"]

        Shading --> Lighting

        subgraph Lighting["LIGHTING CALCULATION"]
            Ambient["ğŸ’¡ Ambient<br/>â”â”â”â”â”â”â”â”<br/>constant 0.3"]

            Diffuse["â˜€ï¸ Directional<br/>â”â”â”â”â”â”â”â”â”â”â”â”<br/>light_dir = (0.5,-1,0.3)<br/>diffuse = max(<br/>  dot(normal, -light_dir),<br/>  0.0<br/>) * 0.7"]

            Emissive["âœ¨ Emissive Area Lights<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>FOR EACH triangle with emissive > 0:<br/>  light_pos = (v0+v1+v2)/3<br/>  to_light = light_pos - hit_pos<br/>  distance = length(to_light)<br/><br/>  IF dot(hit_normal, to_light) < 0: SKIP<br/>  IF dot(light_normal, -to_light) < 0: SKIP<br/><br/>  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br/>  â”‚ ğŸ”´ SHADOW RAY (BOTTLENECK)  â”‚<br/>  â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚<br/>  â”‚ âš ï¸ NO GRID ACCELERATION âš ï¸  â”‚<br/>  â”‚                             â”‚<br/>  â”‚ â€¢ Test ALL boxes O(N)       â”‚<br/>  â”‚ â€¢ Test ALL triangles O(M)   â”‚<br/>  â”‚ â€¢ Per emissive light        â”‚<br/>  â”‚ â€¢ Per shaded pixel          â”‚<br/>  â”‚                             â”‚<br/>  â”‚ DOMINATES PERFORMANCE!      â”‚<br/>  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜<br/><br/>  IF occluded: SKIP<br/><br/>  area = 0.5 * |cross(e1,e2)|<br/>  attenuation = area*facing/(distÂ²+1)<br/>  light += emissive * n_dot_l * attenuation"]
        end

        Lighting --> Combine["ğŸ¨ Combine Color<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>surface = base_color *<br/>  (ambient + diffuse + emissive_light)<br/><br/>accumulated += surface *<br/>  (1 - reflectivity) * multiplier"]

        Combine --> ReflectCheck{"ğŸª Reflect?<br/>â”â”â”â”â”â”â”â”<br/>reflectivity<br/>> 0.01?"}

        ReflectCheck -->|NO| Output
        ReflectCheck -->|YES| PrepBounce["Prepare Next Bounce<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>multiplier *= reflectivity<br/>ray.direction = reflect(<br/>  ray.direction, normal<br/>)<br/>ray.origin =<br/>  hit_pos + normal*0.001"]

        PrepBounce --> BounceCheck{"Bounce < 8?"}
        BounceCheck -->|YES| BounceLoop
        BounceCheck -->|NO| Output

        Output["ğŸ“¤ OUTPUT<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>textureStore(<br/>  output_texture,<br/>  pixel_xy,<br/>  vec4(accumulated, 1.0)<br/>)"]
    end

    Output --> Display["ğŸ–¥ï¸ DISPLAY PIPELINE<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>1. Render Pass<br/>2. Fullscreen Triangle<br/>3. Fragment Shader samples<br/>   output_texture<br/>4. Write to Swapchain"]

    Display --> Done["âœ… FRAME COMPLETE"]

    subgraph Legend["â”â”â” KEY INFORMATION â”â”â”"]
        Info1["ğŸ“Š COMPLEXITY ANALYSIS<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Best:    O(1) - ray misses grid<br/>Average: O(C Ã— K) - C cells, K objs/cell<br/>Worst:   O(200Ã—8192 + EÃ—NÃ—8)<br/>         = ~1.6M + emissive cost<br/><br/>C = cells traversed (10-30 typical)<br/>K = objects per cell (5-50 typical)<br/>E = emissive triangles<br/>N = total geometry"]

        Info2["âš ï¸ BOTTLENECKS<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>ğŸ”´ CRITICAL: Shadow ray O(N+M)<br/>ğŸŸ  HIGH: Fine grid 32KB/cell<br/>ğŸŸ¡ MEDIUM: Scattered memory access<br/>ğŸŸ¡ MEDIUM: Texture in intersection<br/>ğŸŸ¢ LOW: Moving boxes bypass grid"]

        Info3["âœ… OPTIMIZATIONS<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>â€¢ Early ray termination<br/>â€¢ LOD culling (< 2px, > 200 units)<br/>â€¢ Russian roulette (reflect < 0.01)<br/>â€¢ Shadow ray facing checks<br/>â€¢ Safe inverse (epsilon protection)<br/>â€¢ Workgroup size 8Ã—8"]

        Info4["ğŸ’¾ MEMORY LAYOUT<br/>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”<br/>Binding 0: Camera (uniform, 96B)<br/>Binding 1: Grid Meta (uniform, 96B)<br/>Binding 2: Coarse Grid (storage, u8[])<br/>Binding 3: Fine Grid (storage, 32KB/cell)<br/>Binding 4: Boxes (storage, 128B each)<br/>Binding 5: Triangles (storage, 80B each)<br/>Binding 6: Materials (storage, 64B each)<br/>Binding 7: Scene Config (uniform, 16B)<br/>Binding 8: Output Texture (storage, RGBA8)<br/>Binding 11: Texture Array (2D array)<br/>Binding 12: Sampler (linear filter)"]
    end

    style Start fill:#4CAF50,stroke:#2E7D32,stroke-width:3px,color:#fff
    style Done fill:#4CAF50,stroke:#2E7D32,stroke-width:3px,color:#fff
    style CPUPhase fill:#E3F2FD,stroke:#1976D2,stroke-width:2px
    style GPUPhase fill:#FFF3E0,stroke:#F57C00,stroke-width:2px
    style BufferPrep fill:#F5F5F5,stroke:#616161,stroke-width:2px
    style Lighting fill:#FCE4EC,stroke:#C2185B,stroke-width:2px
    style Legend fill:#E8F5E9,stroke:#388E3C,stroke-width:2px
    style Emissive fill:#FFCDD2,stroke:#D32F2F,stroke-width:3px
    style DDALoop fill:#C8E6C9,stroke:#388E3C,stroke-width:2px
    style BounceLoop fill:#E1BEE7,stroke:#7B1FA2,stroke-width:2px
    style StaticBuffers fill:#FFCCBC,stroke:#E64A19,stroke-width:2px
